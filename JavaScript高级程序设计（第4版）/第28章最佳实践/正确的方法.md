在计算机科学中，算法复杂度使用大 O 表示法来表示。最简单同时也最快的算法可以表示为常量值
或 O(1)。然后，稍微复杂一些的算法同时执行时间也更长一些。下表列出了 JavaScript 中常见算法的类型。

O(1) 常量 无论多少值，执行时间都不变。表示简单值和保存在变量中的值
O(logn) 对数 执行时间随着值的增加而增加，但算法完成不需要读取每个值。例子：二分查找
O(n) 线性 执行时间与值的数量直接相关。例子：迭代数组的所有元素
O(n2) 二次方 执行时间随着值的增加而增加，而且每个值至少要读取 n 次。例子：插入排序

常量值或 O(1)，指字面量和保存在变量中的值，表示读取常量值所需的时间不会因值的多少而变化。
读取常量值是效率极高的操作，因此非常快。来看下面的例子：
let value = 5;
let sum = 10 + value;
console.log(sum);
以上代码查询了 4 次常量值：数值 5、变量 value、数值 10 和变量 sum。整体代码的复杂度可以认
为是 O(1)。 在 JavaScript 中访问数组元素也是 O(1)操作，与简单的变量查找一样。因此，下面的代码与前面的
例子效率一样：
let values = [5, 10];
let sum = values[0] + values[1];
console.log(sum);
使用变量和数组相比访问对象属性效率更高，访问对象属性的算法复杂度是 O(n)。访问对象的每个
属性都比访问变量或数组花费的时间长，因为查找属性名要搜索原型链。简单来说，查找的属性越多，
执行时间就越长。来看下面的例子：
let values = { first: 5, second: 10 };
let sum = values.first + values.second;
console.log(sum);
这个例子使用两次属性查找来计算 sum 的值。一两次属性查找可能不会有明显的性能问题，但几百
上千次则绝对会拖慢执行速度。
特别要注意避免通过多次查找获取一个值。例如，看下面的例子：
let query = window.location.href.substring(window.location.href.indexOf("?"));
这里有 6 次属性查找：3 次是为查找 window.location.href.substring()，3 次是为查找
window.location.href.indexOf()。通过数代码中出现的点号数量，就可以知道有几次属性查找。
以上代码效率特别低，这是因为使用了两次 window.location.href，即同样的查找执行了两遍。
只要使用某个 object 属性超过一次，就应该将其保存在局部变量中。第一次仍然要用 O(n)的复杂
度去访问这个属性，但后续每次访问就都是 O(1)，这样就是质的提升了。例如，前面的代码可以重写为
如下：
let url = window.location.href;
let query = url.substring(url.indexOf("?"));
这个版本的代码只有 4 次属性查找，比之前节省了约 33%。在大型脚本中如果能这样优化，可能就
会明显改进性能。
通常，只要能够降低算法复杂度，就应该尽量通过在局部变量中保存值来替代属性查找。另外，如
果实现某个需求既可以使用数组的数值索引，又可以使用命名属性（比如 NodeList 对象），那就都应
该使用数值索引。
